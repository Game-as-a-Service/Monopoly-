using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;

namespace Monopoly.Web.Generators;

[Generator(LanguageNames.CSharp)]
public class TypedSignalrClientGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var attributeContent = SourceText.From(
            """
            // <auto-generated />

            namespace SignalR.Client.Generator
            {
                [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
                public sealed class TypedHubClientAttribute : Attribute
                {
                    private readonly Type _requestType;
                    private readonly Type _responseType;
            
                    public TypedHubClientAttribute(Type requestType, Type responseType)
                    {
                        _requestType = requestType;
                        _responseType = responseType;
                    }
                }
            }
            """
            , Encoding.UTF8);

        context.RegisterPostInitializationOutput(x =>
            x.AddSource("TypedHubClientAttribute.g.cs", attributeContent));

        var provider = context.SyntaxProvider.ForAttributeWithMetadataName(
            "SignalR.Client.Generator.TypedHubClientAttribute",
            predicate: static (node, _) => node.IsKind(SyntaxKind.ClassDeclaration),
            transform: static (ctx, _) => TransformContext(ctx)
        );

        context.RegisterSourceOutput(provider, static (productionContext, nodeInfo) =>
        {
            productionContext.AddSource($"{nodeInfo.Name}.g.cs",
                $$"""
                  // <auto-generated />
                  #nullable enable
                  using Microsoft.AspNetCore.SignalR.Client;

                  namespace {{nodeInfo.Namespace}};

                  public partial class {{nodeInfo.Name}} : {{nodeInfo.RequestInterfaceName}}
                  {
                      private readonly HubConnection hubConnection;
                  {{GenerateDelegates(nodeInfo.ResponseMethods)}}
                      public {{nodeInfo.Name}}(HubConnection hubConnection)
                      {
                          this.hubConnection = hubConnection;
                  {{GenerateEventRegistration(nodeInfo.ResponseMethods)}}
                      }
                  {{GenerateRequests(nodeInfo.RequestMethods)}}
                  }
                  """);
        });
    }

    private static string GenerateRequests(IEnumerable<MethodSymbolWrapper> nodeInfoHubRequestMethods)
    {
        var methods = nodeInfoHubRequestMethods.Select(x =>
        {
            var parameters = string.Join(", ", x.Parameters.Select(p => $"{p.Type} {p.Name}"));
            var parametersInSend = string.Join(", ", x.Parameters.Select(p => p.Name));
            var comma = parametersInSend.Length > 0 ? ", " : "";
            return $$"""
                         public async Task {{x.Name}}({{parameters}})
                         {
                             await hubConnection.SendAsync("{{x.Name}}"{{comma}}{{parametersInSend}});
                         }
                     """;
        });
        return string.Join("\n", methods);
    }

    private static string GenerateEventRegistration(IEnumerable<MethodSymbolWrapper> responseMethods)
    {
        var events = responseMethods.Select(x =>
        {
            var parameters = string.Join(", ", x.Parameters.Select(p => $"{p.Type}"));
            var parametersInOn = string.Join(", ", x.Parameters.Select(p => p.Name));
            var action = $"({parametersInOn}) => {x.Name}Handler?.Invoke({parametersInOn}) ?? Task.CompletedTask";
            return $"""
                           hubConnection.On<{parameters}>("{x.Name}", {action});
                    """;
        });
        return string.Join("\n", events);
    }

    private static string GenerateDelegates(IEnumerable<MethodSymbolWrapper> responseMethods)
    {
        var delegates = responseMethods.Select(x =>
        {
            var parameters = string.Join(", ", x.Parameters.Select(p => $"{p.Type} {p.Name}"));
            return $"""
                        public event {x.Name}Delegate? {x.Name}Handler;
                        public delegate Task {x.Name}Delegate({parameters});
                    """;
        });
        return string.Join("\n", delegates);
    }

    private static (string Name, string Namespace, string RequestInterfaceName, ImmutableArray<MethodSymbolWrapper>
        RequestMethods,
        ImmutableArray<MethodSymbolWrapper> ResponseMethods)
        TransformContext(GeneratorAttributeSyntaxContext ctx)
    {
        var attribute = ctx.Attributes
            .First(x => x.AttributeClass?.Name == "TypedHubClientAttribute");

        var hubRequestType = attribute.ConstructorArguments[0].Value as INamedTypeSymbol;

        var hubRequestInterfaceName = hubRequestType!.ToString();

        var hubResponseType = attribute.ConstructorArguments[1].Value as INamedTypeSymbol;

        var requestMethods = hubRequestType
            .GetMembers()
            .OfType<IMethodSymbol>()
            .Select(x => new MethodSymbolWrapper(x))
            .ToImmutableArray();

        var responseMethods = hubResponseType!
            .GetMembers()
            .OfType<IMethodSymbol>()
            .Select(x => new MethodSymbolWrapper(x))
            .ToImmutableArray();

        return (ctx.TargetSymbol.Name, ctx.TargetSymbol.ContainingNamespace.ToString(), hubRequestInterfaceName,
            requestMethods,
            responseMethods);
    }

    private class MethodSymbolWrapper(IMethodSymbol methodSymbol)
    {
        public string Name => methodSymbol.Name;
        public ImmutableArray<IParameterSymbol> Parameters => methodSymbol.Parameters;

        public override bool Equals(object? obj)
        {
            if (obj is MethodSymbolWrapper other)
            {
                return Name == other.Name
                       && Parameters.SequenceEqual(other.Parameters, new ParameterSymbolComparer());
            }

            return false;
        }

        public override int GetHashCode()
        {
            var hash = 17;
            hash = hash * 23 + SymbolEqualityComparer.Default.GetHashCode(methodSymbol);

            hash = hash * 23 + Name.GetHashCode();

            return Enumerable.Aggregate(
                Parameters, hash,
                (current, parameter) =>
                    current * 23 + SymbolEqualityComparer.Default.GetHashCode(parameter));
        }

        private class ParameterSymbolComparer : IEqualityComparer<IParameterSymbol>
        {
            public bool Equals(IParameterSymbol x, IParameterSymbol y)
            {
                return SymbolEqualityComparer.Default.Equals(x.Type, y.Type) && x.Name == y.Name;
            }

            public int GetHashCode(IParameterSymbol obj)
            {
                var hash = 17;
                hash = hash * 23 + (obj.Name.GetHashCode());
                hash = hash * 23 + SymbolEqualityComparer.Default.GetHashCode(obj.Type);
                return hash;
            }
        }
    }
}