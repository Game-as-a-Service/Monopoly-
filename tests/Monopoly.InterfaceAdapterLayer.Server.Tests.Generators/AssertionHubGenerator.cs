using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;

namespace Monopoly.InterfaceAdapterLayer.Server.Tests.Generators;

[Generator(LanguageNames.CSharp)]
public class AssertionHubGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var attributeContent = SourceText.From(
            """
            // <auto-generated />
            namespace Monopoly.InterfaceAdapters.Server.Tests.Generators
            {
                [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
                public sealed class AssertionHubAttribute : Attribute
                {
                    private readonly Type _requestType;
                    private readonly Type _responseType;
                    
                    public AssertionHubAttribute(Type requestType, Type responseType)
                    {
                        _requestType = requestType;
                        _responseType = responseType;
                    }
                }
            }
            """,
            Encoding.UTF8);

        var assertionEvent = SourceText.From(
            """
            // <auto-generated />

            namespace Monopoly.InterfaceAdapters.Server.Tests.Generators
            {
                public record SignalREvent(string EventName, object[] EventArgs);
            }
            """,
            Encoding.UTF8);

        context.RegisterPostInitializationOutput(x =>
        {
            x.AddSource("AssertionHubAttribute.g.cs", attributeContent);
            x.AddSource("SignalREvent.g.cs", assertionEvent);
        });


        var provider = context.SyntaxProvider.ForAttributeWithMetadataName(
            "Monopoly.InterfaceAdapters.Server.Tests.Generators.AssertionHubAttribute",
            predicate: static (node, _) => node.IsKind(SyntaxKind.ClassDeclaration),
            transform: static (ctx, _) => TransformContext(ctx)
        );

        context.RegisterSourceOutput(provider, static (productionContext, nodeInfo) =>
        {
            var requestClassName = $"{nodeInfo.Name}Request";
            var assertionClassName = $"{nodeInfo.Name}FluentAssertion";
            // partial hub class
            productionContext.AddSource($"{nodeInfo.Name}/{nodeInfo.Name}.g.cs",
                $$"""
                  // <auto-generated />
                  using Microsoft.AspNetCore.SignalR.Client;

                  namespace {{nodeInfo.Namespace}};

                  public partial class {{nodeInfo.Name}}
                  {
                      private readonly HubConnection hubConnection;
                      public {{assertionClassName}} FluentAssert { get; }
                      public {{requestClassName}} Requests { get; }
                      
                      public {{nodeInfo.Name}}(IHubConnectionBuilder hubConnectionBuilder)
                      {
                          this.hubConnection = hubConnectionBuilder.Build();
                          FluentAssert = new {{assertionClassName}}(this.hubConnection);
                          Requests = new {{requestClassName}}(this.hubConnection);
                      }
                      
                      public async Task StartAsync(CancellationToken cancellationToken = default)
                      {
                          await hubConnection.StartAsync(cancellationToken);
                      }
                  }
                  """);

            // request class
            productionContext.AddSource($"{nodeInfo.Name}/{requestClassName}.g.cs",
                $$"""
                  // <auto-generated />
                  using Microsoft.AspNetCore.SignalR.Client;

                  namespace {{nodeInfo.Namespace}};

                  public sealed class {{requestClassName}} : {{nodeInfo.RequestInterfaceName}}
                  {
                      private readonly HubConnection _hubConnection;
                      
                      public {{requestClassName}}(HubConnection hubConnection)
                      {
                          _hubConnection = hubConnection;
                      }
                      
                  {{GenerateRequests(nodeInfo.RequestMethods)}}
                  }
                  """);

            // assertion class
            productionContext.AddSource($"{nodeInfo.Name}/{assertionClassName}.g.cs",
                $$"""
                  // <auto-generated />
                  using Microsoft.AspNetCore.SignalR.Client;
                  using Monopoly.InterfaceAdapters.Server.Tests.Generators;
                  using System.Threading.Channels;

                  namespace {{nodeInfo.Namespace}};

                  public sealed class {{assertionClassName}}
                  {
                      private readonly HubConnection _hubConnection;
                      private readonly Channel<SignalREvent> _events = Channel.CreateUnbounded<SignalREvent>();
                      private readonly CancellationToken _cancellationToken = default;
                      
                      public {{assertionClassName}}(HubConnection hubConnection)
                      {
                          _hubConnection = hubConnection;
                          CancellationTokenSource cts = new CancellationTokenSource(TimeSpan.FromSeconds(10));
                          _cancellationToken = cts.Token;
                  {{GenerateEventRegistration(nodeInfo.ResponseMethods)}}
                      }
                      
                      private async Task<SignalREvent> PopAsync(CancellationToken cancellationToken)
                      {
                          var @event = await _events.Reader.ReadAsync(cancellationToken);
                          return @event;
                      }
                      
                      private SignalREvent Pop(CancellationToken cancellationToken = default)
                      {
                          return PopAsync(cancellationToken).Result;
                      }
                      
                  {{GenerateDelegates(assertionClassName, nodeInfo.ResponseMethods)}}
                      
                  }
                  """);
        });
    }

    private static string GenerateRequests(IEnumerable<IMethodSymbol> nodeInfoHubRequestMethods)
    {
        var methods = nodeInfoHubRequestMethods.Select(x =>
        {
            var parameters = string.Join(", ", x.Parameters.Select(p => $"{p.Type} {p.Name}"));
            var parametersInSend = string.Join(", ", x.Parameters.Select(p => p.Name));
            var comma = parametersInSend.Length > 0 ? ", " : "";
            switch (x.ReturnType)
            {
                // x. Return type is Task or Task<T>
                case INamedTypeSymbol { Name: "Task", IsGenericType: false }:
                    return $$"""
                                 public async Task {{x.Name}}({{parameters}})
                                 {
                                     await _hubConnection.InvokeAsync("{{x.Name}}"{{comma}}{{parametersInSend}});
                                 }
                             """;
                case INamedTypeSymbol { Name: "Task", IsGenericType: true } namedTypeSymbol:
                {
                    var returnType = namedTypeSymbol.TypeArguments[0];
                    return $$"""
                                 public async Task<{{returnType}}> {{x.Name}}({{parameters}})
                                 {
                                     return await _hubConnection.InvokeAsync<{{returnType}}>("{{x.Name}}"{{comma}}{{parametersInSend}});
                                 }
                             """;
                }
                default:
                    return $"return type {x.ReturnType} of {x.Name} is not Task or Task<T>";
            }
        });
        return string.Join("\n", methods);
    }

    private static string GenerateEventRegistration(IEnumerable<IMethodSymbol> responseMethods)
    {
        var events = responseMethods.Select(x =>
        {
            var parameters = string.Join(", ", x.Parameters.Select(p => $"{p.Type}"));
            var parametersInOn = string.Join(", ", x.Parameters.Select(p => p.Name));
            var action =
                $"async ({parametersInOn}) => await _events.Writer.WriteAsync(new SignalREvent(\"{x.Name}\", new object[]{{ {parametersInOn} }}))";
            return $"\t\t_hubConnection.On<{parameters}>(\"{x.Name}\", {action});";
        });
        return string.Join("\n", events);
    }

    private static string GenerateDelegates(string assertClassName, IEnumerable<IMethodSymbol> responseMethods)
    {
        var delegates = responseMethods.Select(x =>
        {
            var parametersInDelegate = string.Join(", ", x.Parameters.Select(p => $"{p.Type} {p.Name}"));
            var parametersInOn = string.Join(", ", x.Parameters.Select(p => p.Name));
            return $$"""
                         public {{assertClassName}} {{x.Name}}({{parametersInDelegate}})
                         {
                             var @event = Pop(_cancellationToken); 
                             Assert.AreEqual("{{x.Name}}", @event.EventName);
                             CollectionAssert.AreEqual(new object[]{ {{parametersInOn}} }, @event.EventArgs);
                             
                             return this;
                         }
                     """;
        });
        return string.Join("\n", delegates);
    }

    private static TransformationResult TransformContext(GeneratorAttributeSyntaxContext ctx)
    {
        var attribute = ctx.Attributes
            .First(x => x.AttributeClass?.Name == "AssertionHubAttribute");

        var hubRequestType = attribute.ConstructorArguments[0].Value as INamedTypeSymbol;

        var hubRequestInterfaceName = hubRequestType!.ToString();

        var hubResponseType = attribute.ConstructorArguments[1].Value as INamedTypeSymbol;

        var requestMethods = hubRequestType
            .GetMembers()
            .OfType<IMethodSymbol>()
            .ToArray();

        var responseMethods = hubResponseType!
            .GetMembers()
            .OfType<IMethodSymbol>()
            .ToArray();

        return new TransformationResult(ctx.TargetSymbol.Name, ctx.TargetSymbol.ContainingNamespace.ToString(),
            hubRequestInterfaceName,
            requestMethods,
            responseMethods);
    }
}